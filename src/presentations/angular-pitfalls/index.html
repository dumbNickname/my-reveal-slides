<html>

<head>
    <link href="https://fonts.googleapis.com/css?family=Pacifico|Shadows+Into+Light" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Handlee|Nothing+You+Could+Do|Open+Sans+Condensed:300" rel="stylesheet">

    <link rel="stylesheet" href="../../../jspm_packages/github/hakimel/reveal.js@3.3.0/css/reveal.css">
    <link rel="stylesheet" href="../../../jspm_packages/github/hakimel/reveal.js@3.3.0/css/theme/white.css">
    <link rel="stylesheet" href="../../../src/css/common.css">
    <link rel="stylesheet" href="../../css/solarized-light.css">
    <link rel="stylesheet" href="./css/angular-pitfalls.css">

    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? './css/print/pdf.css' : './css/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <section data-background-color="#20303b">
                <h1>
                    <span class="secondaryColor">Angular</span>
                </h1>
                <h3><span class="color: #b92526">... lesson learned</span></h3>
              <img class="plain" src="./img/angular-wallpaper.jpg">
                <!-- Image taken from: https://i.ytimg.com/vi/01N3qk-oJf0/maxresdefault.jpg -->

              <p style="margin-left: 17em; margin-top:-6.5em" class="author secondaryColor">
                  <span style="display:block">by</span>
                  <span style="display:block">Ewa Nestorowicz</span>
              </p>
            </section>
            <section data-background-color="var(--primary-color)">
               <span  style="font-size: 6em; font-weight: bold; color: white;">PITFALLS!</span>
            </section>

            <section>
                <h1>
                    Pitfall #1
                </h1>
                <h5 class="fallbackColor">Nested subscriptions</h5>
                <p>The code is <strong>unreadable and complex</strong></p>
                <p>There is <strong>no control</strong> over a stream</p>
                <p>It is <strong>not reactive</strong> and may cause <strong>callback hell</strong></p>
                <pre><code class="javascript">
this.route.params.pipe(
                    map(param => param.id)
                  )
                 .subscribe(id =>
                    this.bookService.getBookById(id)
                        .subscribe(book => this.book = book);
                </code></pre>

            </section>

            <section>
                <h1 class="linkColor">solution #1</h1>
                <p>Use <strong>higher order streams</strong> such as <strong>switchMap</strong></p>
                <pre><code class="javascript">
this.route.params.pipe(
                    map(param => param.id),
                    switchMap(id => this.bookService.getBookById(id))
                  )
                 .subscribe(book => this.book = book);
                </code></pre>
                <iframe class="jsbin" data-src="http://rxmarbles.com/#switchMap"></iframe>
            </section>

            <section>
                <h1>pitfall #2</h1>
                <h5 class="fallBackColor">avoid memory leaks</h5>
                <p>Consider we have a stream...</p>
                <iframe src="https://giphy.com/embed/14aumMYgx9CvKw" width="480" height="277" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/cats-endless-stream-14aumMYgx9CvKw"></a></p>
                <p>If we subscribe to this stream, a <strong>subscription</strong> will be created</p>
            </section>

            <section>
                <h1>so...</h1>
                <h3 class="fallbackColor">... where is the memory leak?</h3>
            </section>

            <section>
                <p>A subscription will exist unless the stream is <strong>completed</strong> or we <strong>unsubscribe </strong> from the stream.</p>
                <pre><code class="javascript">
    const interval$ = interval(1000);
    const subscription = interval$.subscribe(val => console.log(val));
                </code></pre>
                <p>Even if a component gets <strong>destroyed</strong>, the stream <strong>will keep producing values!</strong></p>
                <iframe src="https://giphy.com/embed/eVluHT4JazHZC" width="480" height="259" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/tom-brady-pandawhale-eVluHT4JazHZC"></a></p>
            </section>

            <section>
                <h1 class="linkColor">solution #2</h1>
                <p>1. use <strong>takeUntil</strong> operator</p>
                <p>2. collect <strong>all</strong> subscriptions and <strong>unsubscribe manually</strong></p>
                <p>3. use <strong>async pipe</strong></p>
            </section>

            <section>
                <h3 class="linkColor">1. takeUntil</h3>
                <pre><code>
  private destroy$: Subject< void> = new Subject< void>();
  ngOnInit() {
    this.userService.getUser(id)
      .pipe(takeUntil(this.destroy$))
      .subscribe(user => this.user = user);
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.unsubscribe();
  }
                </code></pre>
            </section>

            <section>
                <h3 class="linkColor">2. Manually unsubscribe</h3>
                <pre><code>
  private subscriptions: [] = [];

  ngOnInit() {
    const subscription =
    this.userService.getUser(id).subscribe(user => this.user = user);

    this.subscriptions.push(subscription);
  }

  ngOnDestroy(): void {
    this.subscriptions.forEach(sub => sub.unsubscribe());
  }
                </code></pre>
            </section>

            <section>
                <h3 class="linkColor">3. Use async pipe</h3>
                <pre><code>
 <book-detail [book]="book$ | async"></book-detail>
                </code></pre>
                <p>1. Unsubscribe is <strong>automatically</strong> when the component gets <strong>destroyed</strong></p>
                <p>2. <strong>Subscription & change detection </strong> is triggered automatically</p>
            </section>

            <section>
                <h3 class="linkColor">When use what?</h3>
                <p>We should use <strong>async pipes</strong> if possible, because updates and unsubscribes are triggered <strong>automatically.</strong></p>
                <p>Instead of manually unsubscribe we should use<strong> takeUntil </strong> operator. If someone analyses a code and sees a stream, it's noticeable that
                    someone was concerned about unsubscribe and we <strong>don't need extra subscription fields</strong> for each stream.</p>
            </section>

            <section>
                <h1 style="display: inline;"> hot </h1>
                <h1 style="display: inline;" class="fallbackColor" style="display: inline-block;"> vs. </h1>
                <h1 style="display: inline;" class="tertiaryColor"> cold </h1>
                <h2 class="fallbackColor"> observables </h2>
                <ul style="text-align: center; list-style:none;">
                    <li><span class="tertiaryColor"><strong>cold</strong></span><span>: observables create a <strong>new producer</strong> <strong> each time</strong> a consumer subscribes to them</span></li>
                    <li><span class="primaryColor"><strong>hot</strong></span><span>: observables <strong>share a single producer</strong> with <strong>every consumer</strong> that subscribes to them</span></li>
                    <li style="margin-top: 1em"><span><strong>each observable</strong> is</span> <span class="tertiaryColor"><strong>cold</strong></span> <span> by default</span></li>
                </ul>
            </section>

            <section data-state="jsbin">
                <h1 class="tertiaryColor"> Cold </h1>
                <h2 class="fallbackColor"> Observable </h2>
                <iframe class="jsbin" data-src="http://jsbin.com/vesakibequ/edit?js,console"></iframe>
            </section>

            <section data-state="jsbin">
                <h1 style="color: orangered" class="tertiaryColor"> Warm </h1>
                <h2 class="fallbackColor"> Observable </h2>
                <iframe class="jsbin" data-src="http://jsbin.com/nanevudubi/edit?js,console"></iframe>
            </section>

            <section data-state="jsbin">
                <h1 class="primaryColor"> Hot </h1>
                <h2 class="fallbackColor"> Observable </h2>
                <iframe class="jsbin" data-src="http://jsbin.com/minoviqefu/edit?js,console"></iframe>
                <p><strong>refCount</strong> returns an observable that maintains a <strong>reference count of subscribers</strong></p>
            </section>

            <section>
                <h1>Pitfall #3</h1>
                <h5 class="fallbackColor">multiple http requests!</h5>
                <pre><code>

<books-overview [books]="books$ | async"></books-overview>
Total number of book: {{numberOfBooks$ | async}}

 ngOnInit() {
    this.books$ = this.bookService.loadBooks();
    // the subscription on this stream will execute the xhr call again
    this.numberOfBooks$ = this.books$.pipe(map(...));
 }
                </code></pre>
                <p>The xhr call will be triggered <strong>twice</strong></p>
                <p style="font-weight: bold" class="primaryColor">numberOfBooks$ depends on books$!</p>
            </section>

            <section>
                <h1>
                    Pitfall #3
                </h1>
                <h5 class="fallbackColor">multiple http requests!</h5>
                <p>Suppose we use async pipe and want to handle some errors...</p>

                <pre><code>
 <books-overview *ngFor="let book of books$ | async"></books-overview>
 ...

 ngOnInit() {
        this.books$ = this.bookService.loadBooks();

        this.books$.subscribe(
            next => console.log(next),
            error => console.error(error),
            () => console.log('completed!')
        );
 }
                </code></pre>

            </section>

            <section>
                <h2>pitfall #3</h2>
                <h5 class="fallbackColor">multiple http requests!</h5>
                <p>what will happen if we subscribe to a stream twice?</p>
                <pre><code>
    List1
    <ul>
      <li *ngFor="let book of books | async">{{book.name}}</li>
    </ul>
    List2
    <ul>
      <li *ngFor="let book of books | async">{{book.authors}}</li>
    </ul>
                </code></pre>
                <p>in the network tab we will see that books were fetched <strong>twice</strong></p>
            </section>

            <section>
             <h2 class="linkColor">solution #3</h2>
                <h5>use publish & share operators!</h5>
                <p>to <strong>share</strong> your subscriptions</p>
                <pre><code>
 ngOnInit() {
   this.books$ = this.bookService.loadBooks().shareReplay(1);
   this.books$ = this.bookService.loadBooks().pipe(share()); // share() === publish().refCount()
 }
                </code></pre>
                <p><strong>share</strong> - only <strong>first value</strong> will be published to <strong>first subscriber</strong>. The second async will <strong>miss it</strong> in case there is a delay</p>
                <p><strong>publishReplay(1) </strong> will keep track of the <strong>previous value of the stream</strong> (recommended)</p>

            </section>

            <section>
                <h1>pitfall #4</h1>
                <h5>don't pass streams to services!</h5>
                <pre><code>
     this.books$ = this.bookService.loadBooks();
     filteredBooks$ = this.bookService.filterBooks(this.books$);
                </code></pre>
                <p style="font-weight: bold" class="primaryColor">We don't know what's gonna happen to this stream!</p>
                <p>May be subscribed to?</p>
                <p>Combined with another stream?</p>
            </section>

            <section>
                <h2 class="linkColor">solution #4</h2>
                <h5>use switch map!</h5>
                <pre><code>
this.books$ = this.bookService.loadBooks();
filteredBooks$ =
this.books$.pipe(switchMap(books => this.bookService.filterBooks(books)));

                </code></pre>
            </section>

            <section data-background-color="#00488D">
                <div style="display: block; font-weight: bold;">
                    <div style="font-size: 4em; color: white;">TIPS</div>
                    <h1 style="color: black;">&</h1>
                    <div style="font-size: 4em; color: #45e6ff;">TRICKS</div>
                </div>
            </section>

            <section>
                <h1 class="tertiaryColor">#1 combine Latest</h1>
                <p>When any observable emits a value, emit the <strong>latest value from each.</strong></p>
                <img src="./img/combineLatest.PNG" alt="" class="plainImage">
            </section>

            <section>
                <h1 class="tertiaryColor">#2 rxjs pipe</h1>
                <h5 class="fallbackColor">available with rxjs 5.5+</h5>
                <h5 class="primaryColor">What are pipes?</h5>
                    <p>Those operators are <strong>pure functions</strong></p>
                    <p>They can be used as <strong>standalone operators </strong>instead of <strong>methods </strong>on an observable</p>
                    <p>They're <strong>lightweight</strong></p>
                    <p>Can <strong>decrease</strong> build size</p>
                    <p>They make code <strong>reusable</strong></p>
            </section>

            <section>
                <h1 class="tertiaryColor">#2 rxjs pipe</h1>
                <pre><code>
        import { range } from 'rxjs/observable/range';
        import { map, filter } from 'rxjs/operators'; // import changed!

        const source$ = range(0, 10);

        source$.pipe(
          filter(x => x % 2 === 0),
          map(x => x + x)
        )
        .subscribe(x => console.log)
                </code></pre>
            </section>

            <section>
                <h1 class="tertiaryColor">pure functions</h1>
                <p><strong>accept </strong>an observable and <strong>return</strong> an observable</p>
                <p>are <strong>tree-shakable</strong> by webpack or other bundlers</p>
                <p>linters can <strong>identify</strong> that the functions are declared/imported but <strong>not used</strong></p>

                <h5 class="primaryColor">Tree-shaking is the process of dead code elimination</h5>
            </section>

            <section>
                <img class="plain" src="./img/pipes.jpeg">
                <!-- Image taken from: https://blog.hackages.io/rxjs-5-5-piping-all-the-things-9d469d1b3f44 -->
            </section>

            <section>
                <h1 class="tertiaryColor">#3 if... else</h1>
                <pre><code>
        <div *ngIf="books$ | async as books; else loading">
            <books-overview [books]="books"></books-overview>
        </div>
        <ng-template #loading>Loading...</ng-template>
                </code></pre>
            </section>

            <section>
                <h1 class="tertiaryColor">#4 The Three Ways to Grab Route Parameters</h1>
                <p>We can grab <strong>route parameters</strong> using:</p>
                <pre><code>
             export const bookDetailsRoute: Route = {
              path: 'book/:id',
              component: BookDetailsComponent,
             }   </code></pre>
                <ul>
                    <li><strong>The Snapshot Way</strong></li>
                    <li><strong>The Observable/Stream Way</strong></li>
                    <li><strong>Route configuration</strong></li>
                </ul>
            </section>

            <section>
                <h1 class="tertiaryColor">The Snapshot Way</h1>
                <p>We can grab <strong>route parameters</strong> using:</p>
                <pre><code class="javascript">
             constructor(private route: ActivatedRoute) {}
             ngOnInit() {
                // this is where we'll grab the data
                // grab them using the snapshot method
                const id = +this.route.snapshot.params['id'];
             }
              </code></pre>
               <p>This will be <strong>enough</strong> to grab the id, but...</p>
                <p>... keep in mind that Angular <strong>reuses components to improve performance.</strong></p>
            </section>

            <section>
                <h2>so what ?</h2>
                <iframe src="https://giphy.com/embed/maIjt7ix50O4g" width="880" height="567" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/reaction-love-it-jealous-maIjt7ix50O4g"></a></p>
            </section>

            <section>
                <h1 class="tertiaryColor">The Snapshot Way</h1>
                <p>If we pick <strong> another book</strong> on this side:</p>
                <h5 class="primaryColor">The component wouldn't update!</h5>
                <p>Keep in mind that:</p>
                <ul>
                    <li>The snapshot method runs <strong>only once</strong> when the component is <strong>initiated</strong></li>
                    <li>If you plan <strong>reusing</strong> the component, use the <strong>observable way</strong></li>
                </ul>
            </section>

            <section>
                <h1 class="tertiaryColor">The Observable Way</h1>
                <p>Observables are <strong>the stream of data</strong></p>
                <h5 class="primaryColor">The Observable will pass along the new data as it changes!</h5>
                <pre><code class="javascript">
                ngOnInit() {
                  // subscribe to the parameters observable
                  this.route.paramMap.subscribe(params => {
                    const id = +params.get('id');
                  });
                }
                </code></pre>
                <p>Please use:</p>
                <ul>
                    <li><strong>paramMap</strong> if you work with <strong>Angular 4+</strong></li>
                    <li><strong>params</strong> if you work with <strong>Angular v2</strong></li>
                </ul>
            </section>

            <section>
            <h1 class="tertiaryColor">Route configuration</h1>
            <p>The option <strong>runGuardsAndResolvers </strong> must be specified. It has three different values:</p>
            <ul>
                <li><strong>paramsChange </strong> this will fire when <strong>route params </strong> have changed: /book/:id</li>
                <li><strong>paramsOrQueryParamsChange </strong> this will fire when either <strong>route param</strong> or <strong> query param</strong> has changed: /books/adventure?limit=10</li>
                <li><strong>always </strong> this will fire <strong> always when route is navigated</strong></li>
            </ul>

            </section>

            <section>
                <h1 class="tertiaryColor">Route configuration</h1>
                <pre><code class="javascript">
export const booksOverviewRoute: Route = {
    path: '',
    children: [
        {
            path: '',
            resolve: {
                products: BooksOverviewResolver,
            },
            component: BooksOverviewComponent,
            runGuardsAndResolvers: 'paramsOrQueryParamsChange',
        }
    ],
};
                </code></pre>
                <h5>By default they run <strong>only when the matrix parameters of the route change</strong></h5>
            </section>

            <section>
                <h1 class="tertiaryColor">#5 bonus</h1>
                <h5 class="fallbackColor">What MAY be wrong with this code?</h5>
                <pre><code>
                          if (book.id) {
                                updateBook(book);
                          } else {
                                saveBook(book);
                          }
                </code></pre>
            </section>

            <section>
                <h1>Q &amp; A</h1>
                <img class="plain" src="./img/Lets-go.png">
            </section>

            <section>
                <h1>Links</h1>
                <ul>
                    <li><a href="https://scotch.io/tutorials/handling-route-parameters-in-angular-v2">handling route parameters in angular</a></li>
                    <li><a href="https://blog.strongbrew.io/rxjs-best-practices-in-angular/">rxjs best practices</a></li>
                    <li><a href="https://blog.angularindepth.com/rxjs-how-to-use-refcount-73a0c6619a4e">rxjs how to use refcount</a></li>
                    <li><a href="https://blog.thoughtram.io/angular/2016/06/16/cold-vs-hot-observables.html">cold vs hot observables</a></li>
                    <li><a href="https://blog.hackages.io/rxjs-5-5-piping-all-the-things-9d469d1b3f44">rxjs pipes</a></li>
                </ul>
            </section>

        </div>
    </div>

    <script src="../../../jspm_packages/system.js"></script>
    <script src="./config.js"></script>
    <script>
        System.import('./js/main');
    </script>
</body>

</html>
